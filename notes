// Node::Index(arr1, index1, ..) => {
//     let arr = if let TokenType::Identifier(ref var) = arr1.token_type {
//         vars.get(var).cloned().unwrap()
//     } else {
//         unreachable!();
//     };
//     let index = self.make_instruction(index1, vars, memory)?;
//     let arr_type = match &arr {
//         Val::Pointer(_, t) => t.clone(),
//         Val::Index(_, ValType::Pointer(t)) => (**t).clone(),
//         _ => {
//             return Err(Error::new(
//                 ErrorType::TypeError,
//                 arr1.position.clone(),
//                 format!("Cannot index type {:?}", arr.r#type()),
//             ))
//         }
//     };
//     let t = arr.r#type();
//     let size = arr.get_size();
//     let mem = memory.allocate(POINTER_SIZE + size);
//     self.instructions.push(
//         Instruction::Add(arr, index),
//         (Some((mem, POINTER_SIZE)), memory.last_memory_index),
//     );
//     self.instructions.push(
//         Instruction::Deref(Val::Index(mem, t)),
//         (Some((mem + POINTER_SIZE, size)), memory.last_memory_index),
//     );
//     Ok(Val::Index(mem + POINTER_SIZE, arr_type))
// }

// Node::IndexAssign(arr1, index1, assign) => {
//     let arr = if let TokenType::Identifier(ref var) = arr1.token_type {
//         vars.get(var).cloned().unwrap()
//     } else {
//         unreachable!();
//     };
//     let index = self.make_instruction(index1, vars, memory)?;
//     let t = arr.r#type();
//     let mem = memory.allocate(POINTER_SIZE);
//     self.instructions.push(
//         Instruction::Add(arr, index),
//         (Some((mem, POINTER_SIZE)), memory.last_memory_index),
//     );
//     let assign = self.make_instruction(assign, vars, memory)?;
//     self.instructions.push(
//         Instruction::DerefAssign(Val::Index(mem, t), assign),
//         (None, memory.last_memory_index),
//     );
//     Ok(Val::None)
// }

// Node::Return(val, ..) => {
//     let val = self.make_instruction(val, vars, memory)?;
//     let &(mem, size) = self.ret.last().unwrap();
//     self.instructions.push(
//         Instruction::Copy(val),
//         (Some((mem, size)), memory.last_memory_index),
//     );
//     Ok(Val::None)
// }

// Node::Expanded(statements, t) => {
//     let t = ValType::from_parse_type(t);
//     let size = t.get_size();
//     let mem = memory.allocate(size);
//     self.ret.push((mem, size));

//     let mut new_vars = vars.clone();
//     let mut new = memory.clone();

//     for statement in statements {
//         self.make_instruction(statement, &mut new_vars, &mut new)?;
//     }
//     self.ret.pop().unwrap();
    // if new.last_memory_index > memory.last_memory_index {
    //     self.instructions.push(
    //         Instruction::Clear(memory.last_memory_index, new.last_memory_index),
    //         (None, memory.last_memory_index),
    //     );
    // }
//     Ok(Val::Index(mem, t))
// }



// Rule::ident => scope
//     .map
//     .get(pair.as_str())
//     .ok_or(Error::UndefinedReference(pair))
//     .and_then(|(p, i)| {
//         if !matches!(p.as_rule(), Rule::expr | Rule::function) {
//             Ok(scope.code.borrow()[*i].kind())
//         } else {
//             Err(Error::TypeError(p.clone()))
//         }
//     }),
// Rule::function => {
//     let mut iter = pair.into_inner();
//     drop(iter.next());
//     let mut ret_kind = ValueKind::None;
//     let mut params = Vec::new();
//     while let Some(next) = iter.peek() {
//         match next.as_rule() {
//             Rule::ident => {
//                 drop(iter.next());
//                 params.push(ValueKind::from_pair(iter.next().unwrap(), scope)?);
//             }
//             Rule::kind => ret_kind = ValueKind::from_pair(iter.next().unwrap(), scope)?,
//             Rule::stmt => break,
//             _ => unreachable!(),
//         }
//     }
//     println!("{}", ret_kind);
// Ok(ValueKind::Function(
//     scope.code.borrow().len(),
//     params,
//     Box::new(ret_kind),
// ))
//     todo!()
// }
// Rule::databox => {
//     let mut iter = pair.into_inner();
//     drop(iter.next());
//     let mut fields = Vec::new();
//     while iter.next().is_some() {
//         fields.push(ValueKind::from_pair(iter.next().unwrap(), scope)?);
//     }
//     // Ok(ValueKind::DataBox(scope.code.borrow().len(), fields));
//     todo!()
// }
